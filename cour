########## access ############

int access( const char * pathname, int aMode );
La fonction access v√©rifie l'existence et les autorisations d'acc√®s au fichier sp√©cifi√© par le param√®tre pathname. 
L'information √† v√©rifier doit √™tre sp√©cifi√© dans le param√®tre aMode.

il est possible de tester plusieurs permissions simultan√©ment en les combinant en utilisant l'op√©rateur binaire |. 
Par exemple, pour tester l'existence et la permission de lecture, on utilisera F_OK | R_OK.

Param√®tres
pathname : ce param√®tre permet d'indiquer le fichier pour lequel r√©aliser les v√©rifications.
aMode : un entier qui repr√©sente le mode d'acc√®s √† tester. Il peut prendre l'un des valeurs suivantes.
F_OK : teste l'existence du fichier.
R_OK : teste la permission de lecture.
W_OK : teste la permission d'√©criture.
X_OK : teste la permission d'ex√©cution.

Valeur de retour
La fonction access renvoie 0 si l'acc√®s au fichier est autoris√© en fonction du mode d'acc√®s sp√©cifi√©. 
Si l'acc√®s est refus√© ou si une erreur s'est produite, la fonction renvoie -1. 
Si une erreur est constat√©e, la variable errno sera fix√©e avec le code erreur constat√©.


########## readline ###################

char *line = readline("minishell$ ");
Affiche le prompt, lit une ligne de l'entr√©e standard (stdin), permet √† l'utilisateur d'√©diter la ligne
 et retourne une cha√Æne allou√©e dynamiquement (√† lib√©rer avec free()).


 if (line && *line)
    add_history(line);
Ajoute la ligne lue √† l‚Äôhistorique (si elle n‚Äôest pas vide).
 Cela permet d‚Äôacc√©der √† cette commande avec les touches fl√©ch√©es (‚Üë ‚Üì).


rl_clear_history();
 Vide toute l'historique (lib√®re la m√©moire allou√©e pour 
 l‚Äôhistorique).


 rl_on_new_line();
 Informe readline qu'une nouvelle ligne est en cours d'√©dition. 
 Cela pr√©pare l‚Äôinterface pour l‚Äôaffichage d‚Äôune nouvelle ligne.



 rl_replace_line(const char *text, int clear_undo)
 rl_replace_line("", 0); // Efface la ligne actuelle
 Remplace le contenu courant de la ligne par text.
  Utile pour effacer la ligne en cours ou y injecter une commande.

Param√®tres :
text : nouveau contenu de la ligne.
clear_undo : si non nul, l‚Äôhistorique d‚Äôannulation est r√©initialis√©.

rl_redisplay(void)
R√©affiche la ligne d‚Äô√©dition actuelle √† l‚Äô√©cran, utile apr√®s un rl_replace_line()
 pour voir les changements.
rl_redisplay();


############### tcgetattr tcsetattr ###################
tcgetattr(int fd, struct termios *termios_p)
But : R√©cup√©rer les param√®tres actuels du terminal r√©f√©renc√© par le descripteur de fichier fd (souvent STDIN_FILENO).

Param√®tres :

fd : descripteur de fichier (souvent STDIN_FILENO)

termios_p : pointeur vers une structure termios que la fonction remplit

Retour : 0 en cas de succ√®s, -1 en cas d‚Äôerreur

üß™ Exemple :
c
Copy
Edit
#include <termios.h>
#include <unistd.h>

struct termios old_termios;

tcgetattr(STDIN_FILENO, &old_termios);
üìò 2. tcsetattr(int fd, int optional_actions, const struct termios *termios_p)
But : Modifier les param√®tres du terminal r√©f√©renc√© par fd.

Param√®tres :

fd : descripteur de fichier

optional_actions : sp√©cifie quand appliquer les changements :

TCSANOW : imm√©diatement

TCSADRAIN : apr√®s l'envoi de toutes les sorties √©crites

TCSAFLUSH : apr√®s l'envoi et l'effacement de toutes les entr√©es non lues

termios_p : les nouvelles configurations

Retour : 0 en cas de succ√®s, -1 en cas d‚Äôerreur


 ############ isatty #############

  ‚Äî Tester si un descripteur de fichier est associ√© √† un terminal
üìò Prototype
c
Copy
Edit
#include <unistd.h>

int isatty(int fd);
üîç Description
La fonction isatty() teste si le descripteur de fichier fd fait r√©f√©rence √† un terminal (TTY = Teletype Terminal). Elle est utilis√©e pour d√©terminer si un programme interagit avec un terminal ou non (par exemple, s‚Äôil est ex√©cut√© en mode interactif ou redirig√©).

‚úÖ Retour
1 : si fd est associ√© √† un terminal

0 : sinon (et errno est d√©fini)

‚ö†Ô∏è Exemple de descripteurs standard
Descripteur	Nom
0	STDIN_FILENO
1	STDOUT_FILENO
2	STDERR_FILENO









